# GATE Algorithms Preparation Checklist

## 1. **Searching Algorithms**
- [ ] **Linear Search**
  - [ ] Algorithm and implementation
  - [ ] Time and space complexity analysis
- [ ] **Binary Search**
  - [ ] Algorithm and implementation
  - [ ] Recursive and iterative approaches
  - [ ] Applications and conditions for use
  - [ ] Time complexity (O(log n))
- [ ] **Advanced Search Techniques**
  - [ ] Interpolation search
  - [ ] Exponential search

## 2. **Sorting Algorithms**
- [ ] **Basic Sorting Algorithms**
  - [ ] Bubble sort
  - [ ] Selection sort
  - [ ] Insertion sort
  - [ ] Time and space complexity analysis
- [ ] **Efficient Sorting Algorithms**
  - [ ] Merge sort
    - [ ] Divide-and-conquer approach
    - [ ] Time complexity (O(n log n))
  - [ ] Quick sort
    - [ ] Partitioning (Lomuto and Hoare methods)
    - [ ] Average and worst-case analysis
  - [ ] Heapsort
    - [ ] Use of binary heap
    - [ ] Time complexity (O(n log n))
- [ ] **Specialized Sorting Algorithms**
  - [ ] Counting sort
  - [ ] Radix sort
  - [ ] Bucket sort

## 3. **Hashing**
- [ ] **Hash Function Design**
  - [ ] Properties of good hash functions
  - [ ] Collision resolution techniques
- [ ] **Collision Resolution Strategies**
  - [ ] Chaining (linked list)
  - [ ] Open addressing (linear probing, quadratic probing, double hashing)
- [ ] **Applications of Hashing**
  - [ ] Hash tables and hash maps
  - [ ] Practical applications (databases, caching)

## 4. **Asymptotic Analysis**
- [ ] **Big O Notation**
  - [ ] Definition and use cases
  - [ ] Simplifying complex expressions
- [ ] **Other Asymptotic Notations**
  - [ ] Omega (Ω) and Theta (Θ) notations
  - [ ] Comparing algorithm efficiency
- [ ] **Space Complexity**
  - [ ] Measuring auxiliary and total space

## 5. **Algorithm Design Techniques**
- [ ] **Greedy Algorithms**
  - [ ] Concept and problem-solving approach
  - [ ] Example problems (activity selection, fractional knapsack)
  - [ ] Analysis of optimality conditions
- [ ] **Dynamic Programming (DP)**
  - [ ] Basic concept (overlapping subproblems and optimal substructure)
  - [ ] Bottom-up and top-down approaches (tabulation and memoization)
  - [ ] Classic DP problems (0/1 knapsack, longest common subsequence, matrix chain multiplication)
- [ ] **Divide-and-Conquer**
  - [ ] Approach and examples
  - [ ] Recurrence relations and their solutions (Master theorem)
  - [ ] Classic problems (merge sort, quick sort, closest pair of points)

## 6. **Graph Algorithms**
- [ ] **Graph Representation**
  - [ ] Adjacency matrix and adjacency list
  - [ ] Directed vs undirected graphs
- [ ] **Graph Traversals**
  - [ ] Depth-first search (DFS)
    - [ ] Recursive and iterative implementations
    - [ ] Time complexity analysis (O(V + E))
  - [ ] Breadth-first search (BFS)
    - [ ] Implementation using queue
    - [ ] Applications (shortest path in unweighted graphs)
- [ ] **Minimum Spanning Trees (MST)**
  - [ ] Kruskal’s algorithm
    - [ ] Union-find data structure
  - [ ] Prim’s algorithm
    - [ ] Priority queue implementation
- [ ] **Shortest Path Algorithms**
  - [ ] Dijkstra’s algorithm (single-source shortest path for non-negative weights)
  - [ ] Bellman-Ford algorithm (handles negative weights)
  - [ ] Floyd-Warshall algorithm (all-pairs shortest path)
- [ ] **Advanced Graph Algorithms**
  - [ ] Topological sorting (for directed acyclic graphs)
  - [ ] Connected components (strongly and weakly connected)

